% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsc.R
\name{dsc}
\alias{dsc}
\title{Generate dynamic subset forecast combinations}
\usage{
dsc(gamma_grid, psi_grid, y, mu_mat, var_mat, delta, n_cores)
}
\arguments{
\item{gamma_grid}{A numerical vector that contains discount factors
to exponentially down-weight the past predictive performance
of the candidate forecasts.}

\item{psi_grid}{An integer vector that controls
the (possible) sizes of the active subsets.}

\item{y}{A matrix of dimension `T * 1` or numeric vector of length `T`
containing the observations of the target variable.}

\item{mu_mat}{A matrix with `T` rows containing
the first moment of each predictive density in each column.}

\item{var_mat}{A matrix with `T` rows containing
the second moment of each predictive density in each column.}

\item{delta}{A numeric value denoting the discount factor used
to down-weight the past predictive performance of the subset combinations.}

\item{n_cores}{An integer that denotes the number of CPU-cores
used for the computational estimation.}
}
\value{
A list that contains
(1) a vector with the first moments (point forecasts) of the STSC-Model,
(2) a vector with the the second moments (variance) of the STSC-Model,
(3) a vector that contains the selected values for gamma,
(4) a vector that contains the selected values for psi and
(5) a matrix that indicates the selected signals for every point in time.
}
\description{
`dsc()` can be used to generate forecast combinations
from a set of candidate density forecasts. For each period,
`dsc()` selects a subset of predictive densities with highest ranks
regarding (local) predictive accuracy.
Both the identities of the candidate forecasts
that are used for building the combined forecast and
the subset sizes may vary over time based on the data.
If only one candidate forecast is picked, the approach (temporarily)
collapses to pure model selection.
}
\examples{
\donttest{

 # Packages
 library("tidyverse")
 library("hdflex")

 # Set Target-Variables
 target_var_names  <- c("GDPCTPI", "PCECTPI", "CPIAUCSL", "CPILFESL")

 # Load Data
 data  <-  inflation_data

 # Loop over Target Variables
 results <-  do.call("rbind", lapply(X = seq_along(target_var_names), FUN = function(p) {

     # Y-Column-Name
     y_target    <-  paste(target_var_names[p], "h_1", sep = "_")
     y_signal    <-  target_var_names[p]
     not_target  <-  setdiff(paste(target_var_names, "h_1", sep = "_"),
                             y_target)

     # Create Forecast-Dataset
     dataset  <-  data                                                    \%>\%
                   select(-any_of(c(y_signal, not_target)))               \%>\%
                   mutate(across(all_of(y_target), .fns = list("lag_1" =
                          ~dplyr::lag(., 1))), .after = 2)                \%>\%
                   mutate(across(all_of(y_target), .fns = list("lag_2" =
                          ~dplyr::lag(., 2))), .after = 3)                \%>\%
                   mutate(across(-c(1, 2, 3, 4), dplyr::lag))             \%>\%
                   slice(-c(1:3))                                         \%>\%
                   column_to_rownames("Date")                             \%>\%
                   as.matrix()

     # Get Dates & Length
     full_dates   <-  rownames(dataset)
     full_length  <-  length(full_dates)

     # Create Time-Sequence for loop
     T_full      <-  full_length -1
     T_sequence  <-  122:T_full

     ### Benchmark Model ###
     # Create Result Matrices for Predictions
     preds_ar2  <-  matrix(NA, ncol = 1, nrow = full_length,
                           dimnames = list(full_dates, "AR"))

     # Create Result Matrices for Squared Errors
     se_ar2     <-  matrix(NA, ncol = 1, nrow = full_length,
                           dimnames = list(full_dates, "AR"))

     # Loop over t
     for(t in T_sequence) {

         ### Pre-Process Data ###
         # Train Data
         x_train     <-  scale(dataset[1:t, -1, drop = FALSE])
         y_train     <-        dataset[1:t,  1, drop = FALSE]

         # Predict Data
         x_pred      <-  scale(dataset[1:(t+1), -1, drop = FALSE])[(t+1), , drop = FALSE]
         y_pred      <-        dataset[t+1, 1]

         ### Model 1: AR(2) ###
         # Train Data
         x_train_ar  <-  cbind(int = 1, x_train[, c(1:2), drop = FALSE])

         # Predict Data
         x_pred_ar   <-  cbind(int = 1,  x_pred[, c(1:2), drop = FALSE])

         # Fit Regressions
         model_ar    <-  .lm.fit(x_train_ar, y_train)

         # Predict & Combine
         pred                  <-  model_ar$coefficients \%*\% x_pred_ar[,]
         preds_ar2[t+1, "AR"]  <-  pred
         se_ar2[t+1, "AR"]     <-  (y_pred - pred) ** 2
     }

     ##### TV-C Models #####
     # Set Target Variable
     Y  <-  dataset[,  1, drop = FALSE]

     # Set 'Simple' Signals
     X  <-  dataset[, -1, drop = FALSE]

     # Load External Point Forecasts (Koop & Korobilis 2023)
     F  <-  get(paste0("Ext_PF_", target_var_names[p]))

     # Set TV-C-Parameter
     sample_length  <-  4 * 3
     lambda_grid    <-  c(0.90, 0.95, 0.99, 0.999, 1)
     kappa_grid     <-  0.98
     n_cores        <-  1

     # Apply TV-C-Function
     results  <-  hdflex::tvc(Y,
                              X,
                              F,
                              lambda_grid,
                              kappa_grid,
                              sample_length,
                              n_cores)

     # Assign Results
     forecast_tvc      <-  results[[1]]
     variance_tvc      <-  results[[2]]
     model_names_tvc   <-  colnames(forecast_tvc)

     # Define Cut Length and Trim Objects
     sample_period_idx  <-  80:full_length
     sub_forecast_tvc   <-  forecast_tvc[sample_period_idx, , drop = FALSE]
     sub_variance_tvc   <-  variance_tvc[sample_period_idx, , drop = FALSE]
     sub_Y              <-  Y[sample_period_idx, , drop = FALSE]
     sub_dates          <-  full_dates[sample_period_idx]
     sub_length         <-  length(sub_dates)

     ##### Dynamic Subset Combination #####
     # Set DSC-Parameter
     nr_mods     <-  ncol(sub_forecast_tvc)
     gamma_grid  <-  c(0.4, 0.5, 0.6, 0.7, 0.8, 0.9,
                       0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99,
                       0.999, 1.00)
     psi_grid    <-  c(1:100)
     delta       <-  0.95
     n_cores     <-  1

     # Apply DSC-Function
     results  <-  hdflex::dsc(gamma_grid,
                              psi_grid,
                              sub_Y,
                              sub_forecast_tvc,
                              sub_variance_tvc,
                              delta,
                              n_cores)

     # Assign Results
     sub_forecast_stsc    <-  results[[1]]
     sub_variance_stsc    <-  results[[2]]
     sub_chosen_gamma     <-  results[[3]]
     sub_chosen_psi       <-  results[[4]]
     sub_pred_pockets     <-  results[[5]]

     # Define Evaluation Period
     eval_date_start      <-  "1991-01-01"
     eval_date_end        <-  "2021-12-31"
     eval_period_idx      <-  which(sub_dates > eval_date_start &
                                    sub_dates <= eval_date_end)

     # Trim Objects
     oos_Y                <-  sub_Y[eval_period_idx, ]
     oos_benchmark        <-  preds_ar2[rownames(preds_ar2) > eval_date_start, "AR"]
     oos_forecast_stsc    <-  sub_forecast_stsc[eval_period_idx]
     oos_variance_stsc    <-  sub_variance_stsc[eval_period_idx]
     oos_chosen_gamma     <-  sub_chosen_gamma[eval_period_idx]
     oos_chosen_psi       <-  sub_chosen_psi[eval_period_idx]
     oos_pred_pockets     <-  sub_pred_pockets[eval_period_idx, , drop = FALSE]
     oos_length           <-  length(eval_period_idx)
     oos_dates            <-  sub_dates[eval_period_idx]

     # Add Dates
     names(oos_forecast_stsc)   <-  oos_dates
     names(oos_variance_stsc)   <-  oos_dates
     names(oos_chosen_gamma)    <-  oos_dates
     names(oos_chosen_psi)      <-  oos_dates
     rownames(oos_pred_pockets) <-  oos_dates

     ##### Evaluate #####
     # Apply Statistial-Evaluation-Function
     summary_results  <-  summary_stsc(oos_Y,
                                       oos_benchmark,
                                       oos_forecast_stsc)
      # Assign MSE-Results
     mse  <-  summary_results[[4]]

     # Return
     return(c(mse[[2]], mse[[1]]))
     }))

 # MSE-Results
 dimnames(results)  <-  list(target_var_names, c("AR", "STSC"))
 round(results / results[, 1], 4)
 }
}
